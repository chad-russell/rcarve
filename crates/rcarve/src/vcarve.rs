use crate::types::{Tool, ToolType};
use anyhow::{anyhow, Result};
use boostvoronoi::{
    Builder, Diagram, Edge,
    Line as VLine, Point as VPoint,
};
use cavalier_contours::polyline::{Polyline, PlineSource, PlineSourceMut, PlineVertex};
use cavalier_contours::core::math::Vector2;
use glam::DVec2;

const SCALE: f64 = 1000.0; // Microns

/// Configuration for the V-Carve operation
#[derive(Debug, Clone)]
pub struct VCarveConfig {
    pub bit_angle_deg: f64,
    pub max_cut_depth: f64,
    pub pruning_angle_threshold_deg: f64,
}

/// Represents the different types of paths generated by the hybrid engine
#[derive(Debug, Clone)]
pub enum PathType {
    /// Derived from Voronoi. Z varies.
    /// Used for corners and narrow sections.
    Crease {
        start: [f64; 3],
        end: [f64; 3],
    },
    /// Derived from Cavalier Contours Offset. Z is constant (max_depth).
    /// Used for wide "pocket" areas.
    PocketBoundary {
        path: Vec<[f64; 2]>,
        depth: f64,
    },
}

/// Represents a polygon (with optional holes) for V-carving.
#[derive(Debug, Clone)]
pub struct CarvePolygon {
    pub outer: Vec<(f64, f64)>,
    pub holes: Vec<Vec<(f64, f64)>>,
}

// Type aliases for Boost Voronoi with i32 input
type I = i32;
type F = f64; // Output coordinate type
type VBLine = VLine<I>;

pub fn generate_vcarve_toolpath(
    polygons: &[CarvePolygon],
    tool: &Tool,
    max_depth: Option<f64>,
) -> Result<Vec<PathType>> {
    let vbit_angle = match tool.tool_type {
        ToolType::VBit { angle_degrees } => angle_degrees,
        _ => return Err(anyhow!("V-carve requires a V-bit tool")),
    };

    let max_depth_value = max_depth.unwrap_or(f64::MAX);
    
    let half_angle_rad = vbit_angle.to_radians() / 2.0;
    let tan_half_angle = half_angle_rad.tan();
    let max_radius = if max_depth.is_some() {
        max_depth_value * tan_half_angle
    } else {
        f64::MAX
    };

    // Config for pruning (hardcoded or derived)
    // Default to ~25 degrees as requested
    let pruning_angle_threshold_deg: f64 = 25.0;
    let pruning_threshold = pruning_angle_threshold_deg.to_radians().cos();

    let mut output_paths = Vec::new();
    
    // 1. Normalize Inputs for Cavalier Contours (CCW outer, CW holes)
    // and convert to Boost Voronoi Segments
    let mut vb_segments: Vec<VBLine> = Vec::new();
    let mut shape_polylines = Vec::new(); // For point-in-poly check and offsetting

    for poly in polygons {
        // Convert outer
        let mut outer_pl = create_clean_polyline(&poly.outer);
        // Ensure CCW
        if outer_pl.area() < 0.0 {
            outer_pl.invert_direction_mut();
        }
        if outer_pl.vertex_count() > 2 {
            add_ring_segments(&outer_pl, &mut vb_segments);
            shape_polylines.push(outer_pl);
        }

        // Convert holes
        for hole in &poly.holes {
            let mut hole_pl = create_clean_polyline(hole);
            // Ensure CW
            if hole_pl.area() > 0.0 {
                hole_pl.invert_direction_mut();
            }
            if hole_pl.vertex_count() > 2 {
                add_ring_segments(&hole_pl, &mut vb_segments);
                shape_polylines.push(hole_pl);
            }
        }
    }

    if vb_segments.is_empty() {
        return Err(anyhow!("No valid segments for V-Carve"));
    }

    // Build Voronoi
    let diagram = Builder::<I, F>::default()
        .with_segments(vb_segments.iter().cloned())?
        .build()
        .map_err(|e| anyhow!("Voronoi build failed: {:?}", e))?;

    // 2. Iterate Edges and Prune (The Spine)
    for edge_rc in diagram.edges() {
        let edge = edge_rc.get();
        
        if !edge.is_primary() {
            continue;
        }
        
        // Check if edge is finite (has both vertices)
        if edge.vertex0().is_none() {
            continue;
        }
        
        // Get twin to check for second vertex
        let twin_edge_id = edge.twin().ok();
        if twin_edge_id.is_none() {
            continue;
        }

        // Check 1: Is this a "Comb" artifact? (Normal Dot Product)
        if !is_valid_medial_edge(&edge, &diagram, pruning_threshold, &vb_segments) {
            continue;
        }

        // Sample the edge into 3D moves
        let samples = sample_edge_to_3d(&edge, &diagram, tan_half_angle, max_depth_value, max_radius, &shape_polylines);
        
        // Convert samples to PathType::Crease
        // samples is Vec<(x,y,z)>
        if samples.len() >= 2 {
            for i in 0..samples.len() - 1 {
                let p1 = samples[i];
                let p2 = samples[i+1];
                output_paths.push(PathType::Crease {
                    start: [p1.0, p1.1, p1.2],
                    end: [p2.0, p2.1, p2.2],
                });
            }
        }
    }

    // 3. Build Rails (Fixed Depth Pocketing)
    // Only if max_depth is limited
    if max_depth.is_some() {
        for pl in &shape_polylines {
            // Offset inwards: For CCW outer polygons, we want to offset inward (shrink).
            // For CW holes, we also want to offset inward relative to the carve area.
            // The cavalier_contours convention: positive delta offsets in the direction
            // of the left-hand normal (which is inward for CCW polygons).
            let offsets = pl.parallel_offset(max_radius);
            
            for offset_pl in offsets {
                let mut points_2d = Vec::new();
                // Use iter_vertexes() to access vertices
                for v in offset_pl.iter_vertexes() {
                    points_2d.push([v.x, v.y]);
                }
                // Close loop if needed
                if !points_2d.is_empty() {
                     let first = points_2d[0];
                     let last = points_2d.last().unwrap();
                     if (first[0] - last[0]).abs() > 1e-6 || (first[1] - last[1]).abs() > 1e-6 {
                         points_2d.push(first);
                     }
                }
                if points_2d.len() >= 2 {
                    output_paths.push(PathType::PocketBoundary {
                        path: points_2d,
                        depth: max_depth_value,
                    });
                }
            }
        }
    }

    Ok(output_paths)
}

/// Create a clean Polyline by filtering out duplicate adjacent points
fn create_clean_polyline(points: &[(f64, f64)]) -> Polyline {
    let mut pline = Polyline::new();
    if points.is_empty() { return pline; }

    let mut last = points[0];
    pline.add_vertex(PlineVertex::new(last.0, last.1, 0.0));
    
    for i in 1..points.len() {
        let curr = points[i];
        if (curr.0 - last.0).abs() > 1e-6 || (curr.1 - last.1).abs() > 1e-6 {
            pline.add_vertex(PlineVertex::new(curr.0, curr.1, 0.0));
            last = curr;
        }
    }
    
    // Check if last point duplicates first point (closed loop)
    // Cavalier contours handles closed loops via set_is_closed, not explicit duplicate point
    if pline.vertex_count() > 1 {
        let first = pline.at(0);
        let last_v = pline.at(pline.vertex_count() - 1);
        if (first.x - last_v.x).abs() < 1e-6 && (first.y - last_v.y).abs() < 1e-6 {
            // Remove last vertex
            // Cavalier contours 0.6 doesn't have a simple remove_last?
            // We'd have to rebuild or just not add it.
            // Since we just added it, we can't easily remove it without a method.
            // Let's reconstruct or use a builder pattern.
            // Actually, let's just rebuild carefully.
        }
    }
    
    // Re-build cleaner to avoid remove_last issue
    let mut final_pline = Polyline::new();
    if points.is_empty() { return final_pline; }
    
    let mut unique_points = Vec::new();
    unique_points.push(points[0]);
    
    for i in 1..points.len() {
        let prev = unique_points.last().unwrap();
        let curr = points[i];
        if (curr.0 - prev.0).abs() > 1e-6 || (curr.1 - prev.1).abs() > 1e-6 {
             unique_points.push(curr);
        }
    }
    
    // If explicitly closed in input (last == first), treat as closed
    let is_explicitly_closed = if unique_points.len() > 1 {
         let first = unique_points[0];
         let last = unique_points.last().unwrap();
         (first.0 - last.0).abs() < 1e-6 && (first.1 - last.1).abs() < 1e-6
    } else {
        false
    };
    
    if is_explicitly_closed {
        unique_points.pop();
    }
    
    for p in unique_points {
        final_pline.add_vertex(PlineVertex::new(p.0, p.1, 0.0));
    }
    
    // We assume closed loops for V-Carve
    final_pline.set_is_closed(true);
    
    final_pline
}

/// Convert Cavalier Polyline to Boost Voronoi segments
fn add_ring_segments(pline: &Polyline, segments: &mut Vec<VBLine>) {
    let count = pline.vertex_count();
    if count < 2 { return; }
    
    for i in 0..count {
        let v1 = pline.at(i);
        let v2 = pline.at((i + 1) % count);
        
        // Scale to integer coordinates for robustness
        let p1 = VPoint { x: (v1.x * SCALE) as i32, y: (v1.y * SCALE) as i32 };
        let p2 = VPoint { x: (v2.x * SCALE) as i32, y: (v2.y * SCALE) as i32 };
        
        segments.push(VBLine::new(p1, p2));
    }
}

/// Critical Pruning Logic
/// Returns true if the edge is a valid medial axis edge (formed by opposing walls),
/// false if it's an artifact (formed by adjacent parallel segments).
fn is_valid_medial_edge(
    edge: &Edge, 
    diagram: &Diagram<F>, 
    pruning_threshold: f64,
    segments: &[VBLine]
) -> bool {
    let cell_a_id = edge.cell().ok();
    if cell_a_id.is_none() {
        return false;
    }
    
    let twin_id = edge.twin().ok();
    if twin_id.is_none() {
        return false;
    }
    
    let twin_rc = diagram.get_edge(twin_id.unwrap()).ok();
    if twin_rc.is_none() {
        return false;
    }
    
    let twin = twin_rc.unwrap();
    let twin_edge = twin.get();
    let cell_b_id = twin_edge.cell().ok();
    if cell_b_id.is_none() {
        return false;
    }
    
    // Get the cells
    let cell_a_rc = diagram.get_cell(cell_a_id.unwrap()).ok();
    let cell_b_rc = diagram.get_cell(cell_b_id.unwrap()).ok();
    
    if cell_a_rc.is_none() || cell_b_rc.is_none() {
        return false;
    }
    
    let cell_a = cell_a_rc.unwrap().get();
    let cell_b = cell_b_rc.unwrap().get();
    
    // Only prune if BOTH are segments.
    // If one is a point (convex corner), we usually want to keep it (it forms the corner crease).
    if !cell_a.contains_segment() || !cell_b.contains_segment() {
        return true;
    }
    
    // Retrieve source segments
    let seg_a_idx = cell_a.source_index();
    let seg_b_idx = cell_b.source_index();
    
    // Check bounds just in case
    if seg_a_idx >= segments.len() || seg_b_idx >= segments.len() {
        return true; 
    }
    
    let seg_a = segments[seg_a_idx];
    let seg_b = segments[seg_b_idx];
    
    // Calculate normals
    // Segment is defined by p0 -> p1
    let a_p0 = DVec2::new(seg_a.start.x as f64, seg_a.start.y as f64);
    let a_p1 = DVec2::new(seg_a.end.x as f64, seg_a.end.y as f64);
    
    let b_p0 = DVec2::new(seg_b.start.x as f64, seg_b.start.y as f64);
    let b_p1 = DVec2::new(seg_b.end.x as f64, seg_b.end.y as f64);
    
    fn get_normal(p0: DVec2, p1: DVec2) -> DVec2 {
        let d = p1 - p0;
        let len = d.length();
        if len < 1e-6 { return DVec2::ZERO; }
        // Rotate 90 degrees (CCW: -y, x) -> Left Normal
        DVec2::new(-d.y, d.x) / len
    }
    
    let normal_a = get_normal(a_p0, a_p1);
    let normal_b = get_normal(b_p0, b_p1);
    
    if normal_a == DVec2::ZERO || normal_b == DVec2::ZERO {
        return true;
    }
    
    let dot = normal_a.dot(normal_b);
    
    // Threshold: if dot > threshold, they are facing same-ish direction -> Artifact
    // We want edges where normals oppose (dot < -threshold) or form a corner.
    // If they are parallel and facing same direction, dot ~= 1.0.
    if dot > pruning_threshold {
        return false; 
    }
    
    true
}

fn sample_edge_to_3d(
    edge: &Edge,
    diagram: &Diagram<F>, 
    tan_half_angle: f64, 
    max_depth: f64,
    max_radius: f64,
    polylines: &[Polyline]
) -> Vec<(f64, f64, f64)> {
    let v0_idx = edge.vertex0();
    if v0_idx.is_none() {
        return Vec::new();
    }
    
    // Get vertex1 from twin edge
    let twin_id = edge.twin().ok();
    if twin_id.is_none() {
        return Vec::new();
    }
    
    let twin_rc = diagram.get_edge(twin_id.unwrap()).ok();
    if twin_rc.is_none() {
        return Vec::new();
    }
    
    let twin = twin_rc.unwrap();
    let v1_idx = twin.get().vertex0();
    if v1_idx.is_none() {
        return Vec::new();
    }
    
    let v0_rc = diagram.vertices().get(v0_idx.unwrap().0);
    let v1_rc = diagram.vertices().get(v1_idx.unwrap().0);
    
    if v0_rc.is_none() || v1_rc.is_none() {
        return Vec::new();
    }
    
    let p0 = v0_rc.unwrap().get();
    let p1 = v1_rc.unwrap().get();
    
    let start = DVec2::new(p0.x() as f64 / SCALE, p0.y() as f64 / SCALE);
    let end = DVec2::new(p1.x() as f64 / SCALE, p1.y() as f64 / SCALE);
    
    let mut points = Vec::new();
    
    // Helper to calc Z and push
    let mut add_point = |pt: DVec2| {
        // Check inside polygon
        let mut is_inside = false;
        for pl in polylines {
             // Fix: Use Vector2 for winding_number
             if pl.winding_number(Vector2::new(pt.x, pt.y)) != 0 {
                 is_inside = true;
                 break;
             }
        }
        
        if !is_inside {
            return; 
        }

        // Calculate distance to site (Radius)
        // We can find the closest distance to ANY site, or the specific site for this cell.
        // For a valid medial axis point, distance to site_a == distance to site_b.
        // We'll use site_a.
        
        // Since we don't have easy access to site geometry from cell->site, 
        // we estimate distance as distance to nearest polyline (accurate enough for v-carve).
        
        let mut min_dist_sq = f64::MAX;
        for pl in polylines {
            // Check distance to all segments of the polyline
            for i in 0..pl.vertex_count() {
                let v1 = pl.at(i);
                let v2 = pl.at((i + 1) % pl.vertex_count());
                
                let a = DVec2::new(v1.x, v1.y);
                let b = DVec2::new(v2.x, v2.y);
                let dist_sq = distance_sq_to_segment(pt, a, b);
                min_dist_sq = min_dist_sq.min(dist_sq);
            }
        }
        
        let radius = min_dist_sq.sqrt();
        
        // Apply Max Radius Bifurcation
        if radius > max_radius {
            return;
        }
        
        let depth = radius / tan_half_angle;
        // Clamp depth to max_depth just in case floating point noise puts it slightly over
        let z = -(depth.min(max_depth));
        
        points.push((pt.x, pt.y, z));
    };

    if edge.is_linear() {
        add_point(start);
        add_point(end);
    } else {
        // Curved edge (Parabolic)
        // Subdivide.
        let count = 10; 
        for i in 0..=count {
             let t = i as f64 / count as f64;
             // Linear approximation for now
             let pt = start.lerp(end, t);
             add_point(pt);
        }
    }
    
    points
}

fn distance_sq_to_segment(p: DVec2, a: DVec2, b: DVec2) -> f64 {
    let ab = b - a;
    let len_sq = ab.length_squared();
    if len_sq < 1e-8 {
        return p.distance_squared(a);
    }
    let t = ((p - a).dot(ab) / len_sq).clamp(0.0, 1.0);
    let closest = a + ab * t;
    p.distance_squared(closest)
}
