use crate::types::{Tool, ToolType};
use anyhow::{anyhow, Result};
use boostvoronoi::{
    Builder, Diagram, Edge,
    Line as VLine, Point as VPoint,
};
use cavalier_contours::polyline::{Polyline, PlineSource, PlineSourceMut, PlineVertex};
use cavalier_contours::core::math::Vector2;
use clipper2::{inflate, EndType, JoinType, Path as CPath, PathType as CPathType, Polygon as CPolygon, Polygons as CPolygons, Vertex as CVertex};
use glam::DVec2;

const SCALE: f64 = 1000.0; // Microns

/// Configuration for the V-Carve operation
#[derive(Debug, Clone)]
pub struct VCarveConfig {
    pub bit_angle_deg: f64,
    pub max_cut_depth: f64,
    pub pruning_angle_threshold_deg: f64,
}

/// Represents the different types of paths generated by the hybrid engine
#[derive(Debug, Clone)]
pub enum PathType {
    /// Derived from Voronoi. Z varies.
    /// Used for corners and narrow sections.
    Crease {
        start: [f64; 3],
        end: [f64; 3],
    },
    /// Derived from Cavalier Contours Offset. Z is constant (max_depth).
    /// Used for wide "pocket" areas.
    PocketBoundary {
        path: Vec<[f64; 2]>,
        depth: f64,
    },
}

/// Debug output containing Voronoi edge information for visualization
#[derive(Debug, Clone, Default)]
pub struct VCarveDebugOutput {
    /// All Voronoi edges before any pruning (finite, primary edges only)
    pub voronoi_edges_pre_prune: Vec<[[f64; 2]; 2]>,
    /// Edges that passed pruning and were kept
    pub voronoi_edges_post_prune: Vec<[[f64; 2]; 2]>,
    /// Edges that were removed by pruning
    pub pruned_edges: Vec<[[f64; 2]; 2]>,
    /// Crease path segments (for separate coloring)
    pub crease_paths: Vec<[[f64; 3]; 2]>,
    /// PocketBoundary path segments (for separate coloring)
    pub pocket_boundary_paths: Vec<Vec<[f64; 2]>>,
}

/// Result of V-carve toolpath generation with optional debug data
#[derive(Debug, Clone)]
pub struct VCarveResult {
    pub paths: Vec<PathType>,
    pub debug: Option<VCarveDebugOutput>,
}

/// Represents a polygon (with optional holes) for V-carving.
#[derive(Debug, Clone)]
pub struct CarvePolygon {
    pub outer: Vec<(f64, f64)>,
    pub holes: Vec<Vec<(f64, f64)>>,
}

// Type aliases for Boost Voronoi with i32 input
type I = i32;
type F = f64; // Output coordinate type
type VBLine = VLine<I>;

/// Generate V-carve toolpath (backward compatible wrapper)
pub fn generate_vcarve_toolpath(
    polygons: &[CarvePolygon],
    tool: &Tool,
    max_depth: Option<f64>,
) -> Result<Vec<PathType>> {
    let result = generate_vcarve_toolpath_with_debug(polygons, tool, max_depth, false)?;
    Ok(result.paths)
}

/// Generate V-carve toolpath with optional debug output
pub fn generate_vcarve_toolpath_with_debug(
    polygons: &[CarvePolygon],
    tool: &Tool,
    max_depth: Option<f64>,
    collect_debug: bool,
) -> Result<VCarveResult> {
    let vbit_angle = match tool.tool_type {
        ToolType::VBit { angle_degrees } => angle_degrees,
        _ => return Err(anyhow!("V-carve requires a V-bit tool")),
    };

    let max_depth_value = max_depth.unwrap_or(f64::MAX);
    
    let half_angle_rad = vbit_angle.to_radians() / 2.0;
    let tan_half_angle = half_angle_rad.tan();
    let max_radius = if max_depth.is_some() {
        max_depth_value * tan_half_angle
    } else {
        f64::MAX
    };

    // Config for pruning (hardcoded or derived)
    // Default to ~25 degrees as requested
    let pruning_angle_threshold_deg: f64 = 25.0;
    let pruning_threshold = pruning_angle_threshold_deg.to_radians().cos();

    let mut output_paths = Vec::new();
    let mut debug_output = if collect_debug {
        Some(VCarveDebugOutput::default())
    } else {
        None
    };
    
    // 1. Normalize Inputs for Cavalier Contours (CCW outer, CW holes)
    // and convert to Boost Voronoi Segments
    let mut vb_segments: Vec<VBLine> = Vec::new();
    let mut shape_polylines = Vec::new(); // For point-in-poly check and offsetting

    for poly in polygons {
        // Convert outer
        let mut outer_pl = create_clean_polyline(&poly.outer);
        // Ensure CCW
        if outer_pl.area() < 0.0 {
            outer_pl.invert_direction_mut();
        }
        if outer_pl.vertex_count() > 2 {
            add_ring_segments(&outer_pl, &mut vb_segments);
            shape_polylines.push(outer_pl);
        }

        // Convert holes
        for hole in &poly.holes {
            let mut hole_pl = create_clean_polyline(hole);
            // Ensure CW
            if hole_pl.area() > 0.0 {
                hole_pl.invert_direction_mut();
            }
            if hole_pl.vertex_count() > 2 {
                add_ring_segments(&hole_pl, &mut vb_segments);
                shape_polylines.push(hole_pl);
            }
        }
    }

    if vb_segments.is_empty() {
        return Err(anyhow!("No valid segments for V-Carve"));
    }

    // Build Voronoi
    let diagram = Builder::<I, F>::default()
        .with_segments(vb_segments.iter().cloned())?
        .build()
        .map_err(|e| anyhow!("Voronoi build failed: {:?}", e))?;

    // 2. Iterate Edges and Prune (The Spine)
    for edge_rc in diagram.edges() {
        let edge = edge_rc.get();
        
        if !edge.is_primary() {
            continue;
        }
        
        // Check if edge is finite (has both vertices)
        if edge.vertex0().is_none() {
            continue;
        }
        
        // Get twin to check for second vertex
        let twin_edge_id = edge.twin().ok();
        if twin_edge_id.is_none() {
            continue;
        }

        // Extract edge coordinates for debug visualization
        let edge_coords = if collect_debug {
            extract_edge_coords(&edge, &diagram)
        } else {
            None
        };

        // Record pre-prune edge if collecting debug
        if let Some(ref mut debug) = debug_output {
            if let Some(coords) = edge_coords {
                debug.voronoi_edges_pre_prune.push(coords);
            }
        }

        // Check 1: Is this a "Comb" artifact? (Normal Dot Product)
        let is_valid = is_valid_medial_edge(&edge, &diagram, pruning_threshold, &vb_segments);
        
        if !is_valid {
            // Record pruned edge if collecting debug
            if let Some(ref mut debug) = debug_output {
                if let Some(coords) = edge_coords {
                    debug.pruned_edges.push(coords);
                }
            }
            continue;
        }

        // Record post-prune edge if collecting debug
        if let Some(ref mut debug) = debug_output {
            if let Some(coords) = edge_coords {
                debug.voronoi_edges_post_prune.push(coords);
            }
        }

        // Sample the edge into 3D moves (can be multiple segments if depth limited)
        let sample_chains = sample_edge_to_3d(&edge, &diagram, tan_half_angle, max_depth_value, &shape_polylines);
        
        // Convert samples to PathType::Crease
        for samples in sample_chains {
            if samples.len() >= 2 {
                for i in 0..samples.len() - 1 {
                    let p1 = samples[i];
                    let p2 = samples[i+1];
                    output_paths.push(PathType::Crease {
                        start: [p1.0, p1.1, p1.2],
                        end: [p2.0, p2.1, p2.2],
                    });
                    
                    // Record crease path for debug
                    if let Some(ref mut debug) = debug_output {
                        debug.crease_paths.push([
                            [p1.0, p1.1, p1.2],
                            [p2.0, p2.1, p2.2],
                        ]);
                    }
                }
            }
        }
    }

    // 3. Build Rails (Fixed Depth Pocketing)
    // Only if max_depth is limited
    if let Some(max_depth_value) = max_depth {
        let offset_delta = -max_radius;
        
        // Use shape_polylines which are already cleaned and oriented correctly
        // (Outer CCW, Holes CW) for Clipper
        let mut paths = Vec::new();
        for pl in &shape_polylines {
            let mut verts = Vec::new();
            for i in 0..pl.vertex_count() {
                let v = pl.at(i);
                verts.push(CVertex::new(v.x, v.y));
            }
            if !verts.is_empty() {
                paths.push(CPath::new(verts, true));
            }
        }

        if !paths.is_empty() {
            let polygon = CPolygon::new(paths, CPathType::Subject);
            let input_polygons = CPolygons::new(vec![polygon]);
            
            let offset_polygons = inflate(
                input_polygons,
                offset_delta,
                JoinType::Miter,
                EndType::ClosedPolygon,
                5.0, // Miter limit
                0.0, // Arc tolerance
            );
            
            for offset_poly in offset_polygons.polygons() {
                for path in offset_poly.paths() {
                    let points: Vec<[f64; 2]> = path.vertices().iter().map(|v| [v.x(), v.y()]).collect();
                    if points.len() < 2 { continue; }
                    
                    let mut closed_points = points.clone();
                    if let (Some(first), Some(last)) = (closed_points.first(), closed_points.last()) {
                         if (first[0] - last[0]).abs() > 1e-6 || (first[1] - last[1]).abs() > 1e-6 {
                             closed_points.push(*first);
                         }
                    }
                    
                    output_paths.push(PathType::PocketBoundary {
                        path: closed_points.clone(),
                        depth: max_depth_value,
                    });
                    
                    if let Some(ref mut debug) = debug_output {
                        debug.pocket_boundary_paths.push(closed_points);
                    }
                }
            }
        }
    }

    Ok(VCarveResult {
        paths: output_paths,
        debug: debug_output,
    })
}

/// Extract 2D coordinates from a Voronoi edge for debug visualization
fn extract_edge_coords(edge: &Edge, diagram: &Diagram<F>) -> Option<[[f64; 2]; 2]> {
    let v0_idx = edge.vertex0()?;
    
    let twin_id = edge.twin().ok()?;
    let twin_rc = diagram.get_edge(twin_id).ok()?;
    let twin = twin_rc.get();
    let v1_idx = twin.vertex0()?;
    
    let v0_rc = diagram.vertices().get(v0_idx.0)?;
    let v1_rc = diagram.vertices().get(v1_idx.0)?;
    
    let p0 = v0_rc.get();
    let p1 = v1_rc.get();
    
    let start = [p0.x() as f64 / SCALE, p0.y() as f64 / SCALE];
    let end = [p1.x() as f64 / SCALE, p1.y() as f64 / SCALE];
    
    Some([start, end])
}

/// Create a clean Polyline by filtering out duplicate adjacent points
fn create_clean_polyline(points: &[(f64, f64)]) -> Polyline {
    let mut pline = Polyline::new();
    if points.is_empty() { return pline; }

    let mut last = points[0];
    pline.add_vertex(PlineVertex::new(last.0, last.1, 0.0));
    
    for i in 1..points.len() {
        let curr = points[i];
        if (curr.0 - last.0).abs() > 1e-6 || (curr.1 - last.1).abs() > 1e-6 {
            pline.add_vertex(PlineVertex::new(curr.0, curr.1, 0.0));
            last = curr;
        }
    }
    
    // Check if last point duplicates first point (closed loop)
    // Cavalier contours handles closed loops via set_is_closed, not explicit duplicate point
    if pline.vertex_count() > 1 {
        let first = pline.at(0);
        let last_v = pline.at(pline.vertex_count() - 1);
        if (first.x - last_v.x).abs() < 1e-6 && (first.y - last_v.y).abs() < 1e-6 {
            // Remove last vertex
            // Cavalier contours 0.6 doesn't have a simple remove_last?
            // We'd have to rebuild or just not add it.
            // Since we just added it, we can't easily remove it without a method.
            // Let's reconstruct or use a builder pattern.
            // Actually, let's just rebuild carefully.
        }
    }
    
    // Re-build cleaner to avoid remove_last issue
    let mut final_pline = Polyline::new();
    if points.is_empty() { return final_pline; }
    
    let mut unique_points = Vec::new();
    unique_points.push(points[0]);
    
    for i in 1..points.len() {
        let prev = unique_points.last().unwrap();
        let curr = points[i];
        if (curr.0 - prev.0).abs() > 1e-6 || (curr.1 - prev.1).abs() > 1e-6 {
             unique_points.push(curr);
        }
    }
    
    // If explicitly closed in input (last == first), treat as closed
    let is_explicitly_closed = if unique_points.len() > 1 {
         let first = unique_points[0];
         let last = unique_points.last().unwrap();
         (first.0 - last.0).abs() < 1e-6 && (first.1 - last.1).abs() < 1e-6
    } else {
        false
    };
    
    if is_explicitly_closed {
        unique_points.pop();
    }
    
    for p in unique_points {
        final_pline.add_vertex(PlineVertex::new(p.0, p.1, 0.0));
    }
    
    // We assume closed loops for V-Carve
    final_pline.set_is_closed(true);
    
    final_pline
}

/// Convert Cavalier Polyline to Boost Voronoi segments
fn add_ring_segments(pline: &Polyline, segments: &mut Vec<VBLine>) {
    let count = pline.vertex_count();
    if count < 2 { return; }
    
    for i in 0..count {
        let v1 = pline.at(i);
        let v2 = pline.at((i + 1) % count);
        
        // Scale to integer coordinates for robustness
        let p1 = VPoint { x: (v1.x * SCALE) as i32, y: (v1.y * SCALE) as i32 };
        let p2 = VPoint { x: (v2.x * SCALE) as i32, y: (v2.y * SCALE) as i32 };
        
        segments.push(VBLine::new(p1, p2));
    }
}

/// Critical Pruning Logic
/// Returns true if the edge is a valid medial axis edge (formed by opposing walls),
/// false if it's an artifact (formed by adjacent parallel segments).
fn is_valid_medial_edge(
    edge: &Edge, 
    diagram: &Diagram<F>, 
    pruning_threshold: f64,
    segments: &[VBLine]
) -> bool {
    let cell_a_id = edge.cell().ok();
    if cell_a_id.is_none() {
        return false;
    }
    
    let twin_id = edge.twin().ok();
    if twin_id.is_none() {
        return false;
    }
    
    let twin_rc = diagram.get_edge(twin_id.unwrap()).ok();
    if twin_rc.is_none() {
        return false;
    }
    
    let twin = twin_rc.unwrap();
    let twin_edge = twin.get();
    let cell_b_id = twin_edge.cell().ok();
    if cell_b_id.is_none() {
        return false;
    }
    
    // Get the cells
    let cell_a_rc = diagram.get_cell(cell_a_id.unwrap()).ok();
    let cell_b_rc = diagram.get_cell(cell_b_id.unwrap()).ok();
    
    if cell_a_rc.is_none() || cell_b_rc.is_none() {
        return false;
    }
    
    let cell_a = cell_a_rc.unwrap().get();
    let cell_b = cell_b_rc.unwrap().get();
    
    // Only prune if BOTH are segments.
    // If one is a point (convex corner), we usually want to keep it (it forms the corner crease).
    if !cell_a.contains_segment() || !cell_b.contains_segment() {
        return true;
    }
    
    // Retrieve source segments
    let seg_a_idx = cell_a.source_index();
    let seg_b_idx = cell_b.source_index();
    
    // Check bounds just in case
    if seg_a_idx >= segments.len() || seg_b_idx >= segments.len() {
        return true; 
    }
    
    let seg_a = segments[seg_a_idx];
    let seg_b = segments[seg_b_idx];
    
    // Calculate normals
    // Segment is defined by p0 -> p1
    let a_p0 = DVec2::new(seg_a.start.x as f64, seg_a.start.y as f64);
    let a_p1 = DVec2::new(seg_a.end.x as f64, seg_a.end.y as f64);
    
    let b_p0 = DVec2::new(seg_b.start.x as f64, seg_b.start.y as f64);
    let b_p1 = DVec2::new(seg_b.end.x as f64, seg_b.end.y as f64);
    
    fn get_normal(p0: DVec2, p1: DVec2) -> DVec2 {
        let d = p1 - p0;
        let len = d.length();
        if len < 1e-6 { return DVec2::ZERO; }
        // Rotate 90 degrees (CCW: -y, x) -> Left Normal
        DVec2::new(-d.y, d.x) / len
    }
    
    let normal_a = get_normal(a_p0, a_p1);
    let normal_b = get_normal(b_p0, b_p1);
    
    if normal_a == DVec2::ZERO || normal_b == DVec2::ZERO {
        return true;
    }
    
    let dot = normal_a.dot(normal_b);
    
    // Threshold: if dot > threshold, they are facing same-ish direction -> Artifact
    // We want edges where normals oppose (dot < -threshold) or form a corner.
    // If they are parallel and facing same direction, dot ~= 1.0.
    if dot > pruning_threshold {
        return false; 
    }
    
    true
}

fn sample_edge_to_3d(
    edge: &Edge,
    diagram: &Diagram<F>, 
    tan_half_angle: f64,
    max_depth: f64, 
    polylines: &[Polyline]
) -> Vec<Vec<(f64, f64, f64)>> {
    let v0_idx = edge.vertex0();
    if v0_idx.is_none() {
        return Vec::new();
    }
    
    // Get vertex1 from twin edge
    let twin_id = edge.twin().ok();
    if twin_id.is_none() {
        return Vec::new();
    }
    
    let twin_rc = diagram.get_edge(twin_id.unwrap()).ok();
    if twin_rc.is_none() {
        return Vec::new();
    }
    
    let twin = twin_rc.unwrap();
    let v1_idx = twin.get().vertex0();
    if v1_idx.is_none() {
        return Vec::new();
    }
    
    let v0_rc = diagram.vertices().get(v0_idx.unwrap().0);
    let v1_rc = diagram.vertices().get(v1_idx.unwrap().0);
    
    if v0_rc.is_none() || v1_rc.is_none() {
        return Vec::new();
    }
    
    let p0 = v0_rc.unwrap().get();
    let p1 = v1_rc.unwrap().get();
    
    let start = DVec2::new(p0.x() as f64 / SCALE, p0.y() as f64 / SCALE);
    let end = DVec2::new(p1.x() as f64 / SCALE, p1.y() as f64 / SCALE);
    
    let max_radius = max_depth * tan_half_angle;

    // Collect raw samples with radius
    let mut raw_samples: Vec<Option<(DVec2, f64)>> = Vec::new();
    
    let get_sample = |pt: DVec2| -> Option<(DVec2, f64)> {
        // Check inside polygon
        let mut is_inside = false;
        for pl in polylines {
             if pl.winding_number(Vector2::new(pt.x, pt.y)) != 0 {
                 is_inside = true;
                 break;
             }
        }
        if !is_inside { return None; }
        
        let mut min_dist_sq = f64::MAX;
        for pl in polylines {
            // Check distance to all segments of the polyline
            for i in 0..pl.vertex_count() {
                let v1 = pl.at(i);
                let v2 = pl.at((i + 1) % pl.vertex_count());
                
                let a = DVec2::new(v1.x, v1.y);
                let b = DVec2::new(v2.x, v2.y);
                let dist_sq = distance_sq_to_segment(pt, a, b);
                min_dist_sq = min_dist_sq.min(dist_sq);
            }
        }
        Some((pt, min_dist_sq.sqrt()))
    };

    if edge.is_linear() {
        raw_samples.push(get_sample(start));
        raw_samples.push(get_sample(end));
    } else {
        // Curved edge (Parabolic)
        // Subdivide.
        let count = 10; 
        for i in 0..=count {
             let t = i as f64 / count as f64;
             // Linear approximation for now
             let pt = start.lerp(end, t);
             raw_samples.push(get_sample(pt));
        }
    }

    let mut chains = Vec::new();
    let mut current_chain = Vec::new();
    
    for i in 0..raw_samples.len().saturating_sub(1) {
        let u_opt = raw_samples[i];
        let v_opt = raw_samples[i+1];
        
        if u_opt.is_none() || v_opt.is_none() {
            if !current_chain.is_empty() {
                chains.push(current_chain);
                current_chain = Vec::new();
            }
            continue;
        }
        
        let (u_pt, u_r) = u_opt.unwrap();
        let (v_pt, v_r) = v_opt.unwrap();
        
        let u_valid = u_r <= max_radius;
        let v_valid = v_r <= max_radius;
        
        if u_valid && v_valid {
            if current_chain.is_empty() {
                current_chain.push((u_pt.x, u_pt.y, -(u_r / tan_half_angle)));
            }
            current_chain.push((v_pt.x, v_pt.y, -(v_r / tan_half_angle)));
        } else if u_valid && !v_valid {
            if current_chain.is_empty() {
                current_chain.push((u_pt.x, u_pt.y, -(u_r / tan_half_angle)));
            }
            // Interpolate transition point
            let t = (max_radius - u_r) / (v_r - u_r);
            let pt = u_pt + (v_pt - u_pt) * t;
            current_chain.push((pt.x, pt.y, -max_depth));
            
            chains.push(current_chain);
            current_chain = Vec::new();
        } else if !u_valid && v_valid {
            if !current_chain.is_empty() {
                chains.push(current_chain);
                current_chain = Vec::new();
            }
            // Interpolate transition point
            let t = (max_radius - u_r) / (v_r - u_r);
            let pt = u_pt + (v_pt - u_pt) * t;
            current_chain.push((pt.x, pt.y, -max_depth));
            current_chain.push((v_pt.x, v_pt.y, -(v_r / tan_half_angle)));
        } else {
            // Both invalid - skip
             if !current_chain.is_empty() {
                chains.push(current_chain);
                current_chain = Vec::new();
            }
        }
    }
    
    if !current_chain.is_empty() {
        chains.push(current_chain);
    }
    
    chains
}

fn distance_sq_to_segment(p: DVec2, a: DVec2, b: DVec2) -> f64 {
    let ab = b - a;
    let len_sq = ab.length_squared();
    if len_sq < 1e-8 {
        return p.distance_squared(a);
    }
    let t = ((p - a).dot(ab) / len_sq).clamp(0.0, 1.0);
    let closest = a + ab * t;
    p.distance_squared(closest)
}
